### OOM错误，StackOverFlow错误，PermGen space错误

> 堆：存放对象实例，溢出-不断向list添加元素
>
> 虚拟机栈(StackOverFlow错误)：存放调用的方法栈帧，溢出-递归调用无退出条件时
>
> 方法区和常量池溢出(PermGen space错误)：调用String.intern()方法，不断地向常量池中添加字符串

### JVM的编译优化

> 早期优化：
>
> 1. 泛型与类型擦除
> 2. 自动装箱、拆箱与遍历循环
> 3. 条件编译
>
> 晚期优化：
>
> 1. 公共子表达式消除
> 2. 数组边界检查消除
> 3. 方法内联
> 4. 逃逸分析

### JVM分配内存的两种方式

> 当使用new关键字创建一个类的对象时，虚拟机需要为新生对象分配内存空间，而对象的大小在类加载完成后已经确定了，所以分配内存只需要在Java堆中划分出一块大小相等的内存。在Java虚拟机中有指针碰撞和空闲列表两种方式分配内存。
>
> 1. **指针碰撞方式**
>    如果Java堆中内存是规整排列的，所有被用过的内存放一边，空闲的可用内存放一边，中间放置一个指针作为它们的分界点，在需要为新生对象分配内存的时候，只要将指针向空闲内存那边挪动一段与对象大小相等的距离即可分配。
>2. 空闲列表方式
> 如果Java堆中内存不是规整排列的，用过的内存和可用内存是相互交错的，这种情况下将不能使用指针碰撞方式分配内存，Java虚拟机需要维护一个列表用于记录哪些内存是可用的，在为新生对象分配内存的时候，在列表中寻找一块足够大的内存分配，并更新列表上的记录。
>    3. Java虚拟机选择策略
> Java虚拟机采用哪种方式为新生对象分配内存，取决于所使用的垃圾收集器，当垃圾收集器具有整理过程时，虚拟机将采用指针碰撞的方式；当垃圾收集器的回收过程没有整理过程时，则采用空闲列表方式。









